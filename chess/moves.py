# -*- coding: utf-8 -*-
"""Move Generation and Ordering"""

from collections import namedtuple
from queue import PriorityQueue

from chess import pregame

from debug import *

# todo: remove fields not needed outside this file
Move = namedtuple('Move', ('start', 'end', 'pieceType', 'color', 'captureType',
						   'captureStrength', 'isPrincipleVariation'))

class MoveOrdering(PriorityQueue):
	"""Orders moves based on their potential"""

	def __init__(self):
		super().__init__()
		self.size = 0

	def push(self, move):
		if move.isPrincipleVariation:  priority = 6
		elif move.captureType is None: priority = 6
		elif move.captureStrength < 0: priority = 7
		else:						   priority = 5-move.captureStrength

		self.put((priority,move))
		self.size += 1

	def clear(self):
		self.size = 0
		super().clear()

	def pop(self):
		self.size -= 1
		priority,move = self.get()
		return move

	def __len__(self):
		return self.size

class Generator:
	"""Legal Move Generator"""

	def __init__(self):
		self.masks = pregame.load_move_masks()
		self.moves, self.movesets = pregame.load_move_cache()
		self.bishopMagic,self.rookMagic = pregame.load_magic()

		self.principleVariations = {}

	def find_attacks(self, state): # param should be pieces param
		"""Generates attack bitboards for all pieces of both colors

		Pawn, Knight, and King attacks are generated by retrieving hashed
		move bitboards (precomputed in pregame) and bitwise subtracting
		occupancy bitboards. Sliding Pieces attacks are generated using
		blocker subtraction, with the o ^ (o - 2s) algorithm
		"""

		attacks = [],[]
		attackSets = [0]*2

		# Iterating state.pieces will always result in same order
		for piece,pieceType,color in state.pieces:

			#PAWN: retrieve precomputed, hashed attack set (with color)
			if pieceType == 0:
				pieceAttacks = self.movesets[pieceType][color][piece][1]

			# KING AND KNIGHT: retrieve precomputed, hashed attack set
			elif pieceType == 5 or pieceType == 1:
				pieceAttacks = self.movesets[pieceType][piece]

			# ROOK/BISHOP: rank + file moves or diagonal + antidiagonal moves
			elif pieceType == 2 or pieceType == 3 :
				pieceAttacks = self.search_magic_cache(piece,pieceType,
													   state.occupied)
				# pieceAttacks = self.get_straight_moves(piece, state.occupied)

			# QUEEN: rank + file + diagonal + antidiagonal moves
			elif pieceType == 4:
				# combine bishop and rook attacks
				straights = self.search_magic_cache(piece, 2, state.occupied)
				diagonals = self.search_magic_cache(piece, 3, state.occupied)
				pieceAttacks = straights | diagonals
			# BISHOP: Diagonal and anti diagonal moves
			# elif pieceType == 2:
			# 	pieceAttacks = self.get_diagonal_moves(piece, state.occupied)

				# straightRays = self.get_straight_moves(piece, state.occupied)
				# diagonalRays = self.get_diagonal_moves(piece, state.occupied)
				# pieceAttacks = straightRays | diagonalRays

			attacks[color].append(pieceAttacks)
			attackSets[color] |= pieceAttacks

		return attacks, attackSets

	def search_magic_cache(self, piece, pieceType, occupied):
		magic = self.bishopMagic if pieceType == 2 else self.rookMagic
		blockers = magic.attacks[piece] & occupied

		# print(pieceType)
		# input()
		# print_bitboard(piece)
		# print_bitboard(magic.attacks[piece])
		# print_bitboard(blockers)
		# print_bitboard(blockers *  magic.bitboards[piece])
		magicBitboard = magic.bitboards[piece]
		numAttackIndecies = magic.indecies[piece]
		magicKey = (blockers * magicBitboard) >> (64 - numAttackIndecies)

		# print('_'*10)
		# for key,value in magic.cache[piece].items():
		# 	print_bitboard(key)
		# 	print_bitboard(value)
		# 	print('_'*10)
		# input()
		return magic.cache[piece][magicKey]

	def find_moves(self, state, attacks, attackSets, onlyCaptures=False, sort=False):
		"""Returns a Move Ordering Priority Queue with legal moves"""

		moves = MoveOrdering()

		color = state.colorToMove
		friends = state.colors[color]
		enemies = state.colors[not color]
		threatened = attackSets[not color]

		pieceIndex = 0
		for piece, pieceType in state.pieces.get_color(color):
			pieceAttacks = attacks[color][pieceIndex]
			pieceIndex+=1

			# PAWN LEGAL MOVE MASK
			if pieceType == 0:
				moveset,attackSet = self.movesets[0][color][piece]

				blocker = self.masks.pawnBlockers[color][piece]

				pawnIsBlocked = blocker & state.occupied != 0

				if pawnIsBlocked:
					moveMask = 0
				else:
					moveMask = moveset & ~state.occupied

				attackMask = attackSet & enemies

				legalMoveMask = attackMask | moveMask

			# KING LEGAL MOVE MASK
			elif pieceType == 5:
				legalMoveMask = pieceAttacks & ~friends & ~threatened

			# KNIGHT, BISHOP, ROOK, QUEEN LEGAL MOVE MASK
			else:
				legalMoveMask = pieceAttacks & ~friends

			# get cached move lists
			if pieceType == 0: # PAWN
				cachedMoves = self.moves[pieceType][color][piece]
			else:
				cachedMoves = self.moves[pieceType][piece]

			for moveBitboard in cachedMoves:
				if moveBitboard & legalMoveMask != 0:
					isACapture = moveBitboard & enemies != 0
					if isACapture:
						captureType = state.get_piece_type(moveBitboard)
						get_piece_rank = lambda pt: pt-1 if pt>1 else pt

						captureStrength = get_piece_rank(captureType) \
										- get_piece_rank(pieceType)

						move = Move(piece, moveBitboard, pieceType, color,
								 	captureType, -1, False)
					else:
						move = Move(piece, moveBitboard, pieceType,
								 color, None, -1, False)

					if onlyCaptures and move.captureStrength < 0: continue
					moves.push(move)

		return moves

	def set_a_principle_variation(self, state, move):
		self.principleVariations[state] = move

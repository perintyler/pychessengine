# -*- coding: utf-8 -*-
"""Move Generation and Ordering"""

from collections import namedtuple
from queue import PriorityQueue

from chess import pregame

# todo: remove fields not needed outside this file
Move = namedtuple('Move', ('start', 'end', 'pieceType', 'color', 'captureType',
                           'captureStrength', 'isPrincipleVariation'))

class MoveOrdering(PriorityQueue):
  """Orders moves based on their potential"""

  def __init__(self):
    super().__init__()
    self.size = 0

  def push(self, move):
    if move.isPrincipleVariation:  priority = 0
    elif move.captureType is None: priority = 6
    elif move.captureStrength < 0: priority = 7
    else:                          priority = 5-move.captureStrength

    self.put((priority,move))
    self.size += 1

  def clear(self):
    self.size = 0
    super().clear()

  def pop(self):
    self.size -= 1
    priority,move = self.get()
    return move

  def __len__(self):
    return self.size

class Generator:
  """Legal Move Generator"""

  def __init__(self):
    self.masks = pregame.load_move_masks()
    self.moves, self.movesets = pregame.load_move_cache()
    self.bishopMagic,self.rookMagic = pregame.load_magic()

    self.principleVariations = {}

  def find_attacks(self, state): # param should be pieces param
    """Generates attack bitboards for all pieces of both colors

    Pawn, Knight, and King attacks are generated by retrieving hashed
    move bitboards (precomputed in pregame) and bitwise subtracting
    occupancy bitboards. Sliding Pieces attacks are generated using
    magic bitboards.
    """

    attacks = [],[]
    attackSets = [0]*2

    # Iterating state.pieces will always result in same order
    for piece,pieceType,color in state.pieces:

      #PAWN: retrieve precomputed, hashed attack set (with color)
      if pieceType == 0:
        pieceAttacks = self.movesets[pieceType][color][piece][1]

      # KING AND KNIGHT: retrieve precomputed, hashed attack set
      elif pieceType == 5 or pieceType == 1:
        pieceAttacks = self.movesets[pieceType][piece]

      # ROOK/BISHOP: rank + file moves or diagonal + antidiagonal moves
      elif pieceType == 2 or pieceType == 3:
        args = (piece,pieceType,state.occupied)
        pieceAttacks = self.search_magic_cache(*args)

      # QUEEN: rank + file + diagonal + antidiagonal moves
      elif pieceType == 4:
        # combine bishop and rook attacks
        straights = self.search_magic_cache(piece, 2, state.occupied)
        diagonals = self.search_magic_cache(piece, 3, state.occupied)
        pieceAttacks = straights | diagonals


      attacks[color].append(pieceAttacks)
      attackSets[color] |= pieceAttacks

    return attacks, attackSets

  def search_magic_cache(self, piece, pieceType, occupied):
    """Magic Bitboards"""
    magic = self.bishopMagic if pieceType == 2 else self.rookMagic
    blockers = magic.attacks[piece] & occupied
    magicBitboard = magic.bitboards[piece]
    numAttackIndecies = magic.indecies[piece]
    magicKey = (blockers * magicBitboard) >> (64 - numAttackIndecies)
    return magic.cache[piece][magicKey]

  def find_captures(self, state, attacks, attackSets):
    return self.find_moves(state, attacks, attackSets, minCaptureStrength = -6)

  def find_strong_captures(self, state, attacks, attackSets, findTrades=False):
    return self.find_moves(state, attacks, attackSets,
                           minCaptureStrength = 0 if findTrades else 1)

  def find_moves(self, state, attacks, attackSets, minCaptureStrength=None):
    """Returns a Move Ordering Priority Queue with legal moves"""

    onlyCaptures = minCaptureStrength is not None
    moves = MoveOrdering()

    color = state.colorToMove
    friends = state.colors[color]
    enemies = state.colors[not color]
    threatened = attackSets[not color]

    pieceIndex = 0
    for piece, pieceType in state.pieces.get_color(color):
      pieceAttacks = attacks[color][pieceIndex]
      pieceIndex+=1

      # PAWN LEGAL MOVE MASK
      if pieceType == 0:
        moveset,attackSet = self.movesets[0][color][piece]

        blocker = self.masks.pawnBlockers[color][piece]

        pawnIsBlocked = blocker & state.occupied != 0

        if pawnIsBlocked:
          moveMask = 0
        else:
          moveMask = moveset & ~state.occupied

        attackMask = attackSet & enemies

        legalMoveMask = attackMask | moveMask

      # KING LEGAL MOVE MASK
      elif pieceType == 5:
        legalMoveMask = pieceAttacks & ~friends & ~threatened

      # KNIGHT, BISHOP, ROOK, QUEEN LEGAL MOVE MASK
      else:
        legalMoveMask = pieceAttacks & ~friends

      # get cached move lists
      if pieceType == 0: # PAWN
        cachedMoves = self.moves[pieceType][color][piece]
      else:
        cachedMoves = self.moves[pieceType][piece]

      for moveBitboard in cachedMoves:
        if moveBitboard & legalMoveMask != 0:
          isACapture = moveBitboard & enemies != 0
          if isACapture:
            captureType = state.get_piece_type(moveBitboard)

            # piece rank sets bishop and knight to be same value
            get_piece_rank = lambda pt: pt-1 if pt>=2 else pt

            captureStrength = get_piece_rank(captureType) \
                            - get_piece_rank(pieceType)

            move = Move(piece, moveBitboard, pieceType, color,
                        captureType, captureStrength, False)
          else:
            move = Move(piece, moveBitboard, pieceType,
                        color, None, None, False)


          if onlyCaptures and (move.captureType is None
              or minCaptureStrength > move.captureStrength): continue

          moves.push(move)


    return moves

  def set_a_principle_variation(self, state, move):
    self.principleVariations[state] = move

# valuation.py
# ---------------------------------------------------------------
# This file is responsible for evaluating a position, which
# is used when searching for best move. A positive valuation
# means white is winning, and a negative valuation means
# black is winning (zero-sum). The valuation is computed by
# quantifying chess concepts. The concepts used are material,
# piece square tables, center control, mobility, connectivity,
# development, bishop pair, and pawn structure. The Evaluater
# class should not be imported directly. Instead import valuator, 
# which is the Valuater instance found at the bottom of this file
# to ensure valuations are cached. 
# ---------------------------------------------------------------

from timer import timeit
from color import WHITE,BLACK
from masks import get_file_mask
from bitboard import Bitboard
import pst # piece square table

#################################################################
# MATERIAL                                 						#        
#################################################################

def count_material_difference(white, black):
	whiteMaterial = blackMaterial = 0
	for piece in white.pieces:
		whiteMaterial += piece.get_value()
	for piece in black.pieces:
		blackMaterial += piece.get_value()
	return whiteMaterial - blackMaterial

#################################################################
# CENTER CONTROL                        						#        
#################################################################

def get_center_control(white, black):
	return white.numCenterAttacks - black.numCenterAttacks

#################################################################
# PIECE SQUARE TABLES                     						#        
#################################################################

def count_pst_values(white, black, numWhitePieces, numBlackPieces):
	whitePST = blackPST = 0
	for piece in white.pieces:
		whitePST += pst.get_square_value(piece)
	for piece in black.pieces:
		blackPST += pst.get_square_value(piece)
	whitePST /= numWhitePieces
	blackPST /= numBlackPieces
	return whitePST - blackPST

#################################################################
# MOBILITY                                 						#        
#################################################################

# Mobility is computed using the number of legal moves for 
# each side. Since moves are only generated by the moving
# player, the number of legal moves for the non moving player
# is determined by using the previous position
def get_mobility(position, numWhitePieces, numBlackPieces):
	if position.lastPosition is None:
		mobility = 0
	else:
		movingPlayerMobility = position.numMoves# len(position.children)
		otherPlayerMobility = position.lastPosition.numMoves#len(position.parent.children)
		if position.board.colorToMove == WHITE:
			whiteMobility = movingPlayerMobility
			blackMobility = otherPlayerMobility
		else:
			whiteMobility = otherPlayerMobility
			blackMobility = movingPlayerMobility
		whiteMobility /= numWhitePieces
		blackMobility /= numBlackPieces
		mobility = whiteMobility - blackMobility
	return mobility

#################################################################
# CONNECTIVITY                                 					#        
#################################################################

def get_connectivity(white, black, numWhitePieces, numBlackPieces):
	whiteConnectivity = white.connectivity / numWhitePieces
	blackConnectivity = black.connectivity / numBlackPieces
	return whiteConnectivity - blackConnectivity

#################################################################
# BISHOP PAIR                                 					#        
#################################################################

def get_bishop_pair_bonus(white,black):
	# returns 1 if only white has bishop pair, 0 if both or neither
	# black and white have bishop pair, and -1 if only black has it
	return white.hasBishopPair - black.hasBishopPair

#################################################################
# PAWN STRUCTURE                                 				#        
#################################################################

# Returns a list containing the number of pawns on each file
def count_pawns_per_file(white, black):
	whitePawnCounts,blackPawnCounts = [],[]
	for file in range(8):
		fileMask = get_file_mask(file)
		numWhitePawns = (white.pawns & fileMask).count_on_bits()
		numBlackPawns = (black.pawns & fileMask).count_on_bits()
		whitePawnCounts.append(numWhitePawns)
		blackPawnCounts.append(numBlackPawns)
	return whitePawnCounts, blackPawnCounts

# counts the number of doubled pawns, isolated pawns, and
# center pawns for each color
def get_pawn_structure_score(white,black):
	numWhiteDoubledPawns = numBlackDoubledPawns = 0
	numWhiteIsoPawns = numBlackIsoPawns = 0	
	whitePawnCounts,blackPawnCounts = count_pawns_per_file(white,black)
	for file in range(8):
		numWhitePawns = whitePawnCounts[file]
		numBlackPawns = blackPawnCounts[file]

		# check for doubled pawns
		if numWhitePawns > 1: numWhiteDoubledPawns += 1
		if numBlackPawns > 1: numBlackDoubledPawns += 1

		# use neighbor files to check for isolated pawns
		if file == 0: neighbors = [ file+1 ]
		elif file == 7: neighbors = [ file-1 ]
		else: neighbors = [ file-1, file+1 ]
		whiteHasNeighbor = blackHasNeighbor = False
		for neighborFile in neighbors:
			if whitePawnCounts[neighborFile] == 0:
				whiteHasNeighbor = True 
			if blackPawnCounts[neighborFile] == 0:
				blackHasNeighbor = True
		if numWhitePawns != 0 and whiteHasNeighbor == False:
			numWhiteIsoPawns += 1
		if numBlackPawns != 0 and blackHasNeighbor == False:
			numBlackIsoPawns += 1

	# count the number of center pawns on files 3 and 4
	numWhiteCenterPawns = whitePawnCounts[3] + whitePawnCounts[4]
	numBlackCenterPawns = blackPawnCounts[3] + blackPawnCounts[4]

	# More center pawns should increase the pawn score, and more
	# doubled and isolated pawns should decrease pawn score. 
	# Pawn score = center pawns - doubled pawns - iso pawns
	whitePawnScore = numWhiteCenterPawns
	whitePawnScore -= (numWhiteDoubledPawns + numBlackIsoPawns)

	blackPawnScore = numBlackCenterPawns
	blackPawnScore -= (numBlackDoubledPawns + numBlackIsoPawns)

	return whitePawnScore - blackPawnScore

 
#################################################################
# Development                                   				#        
#################################################################

B1,G1 = 1,6 # white knight start squares
B8,G8 = 57,62 # black knight start squares

C1,F1 = 2,5 # white bishop start squares
C8,F8 = 58,61 # black bishop start squares

WHITE_MINOR_PIECE_START_SQUARES = [1,2,5,6]
BLACK_MINOR_PIECE_START_SQUARES = [57,58,61,62]

def get_development(white,black):
	whiteMinorPiecesDeveloped = blackMinorPiecesDeveloped = 0
	
	for square in WHITE_MINOR_PIECE_START_SQUARES:
		if white.development.is_bit_on(square):
			whiteMinorPiecesDeveloped+=1
	
	for square in BLACK_MINOR_PIECE_START_SQUARES:
		if black.development.is_bit_on(square):
			blackMinorPiecesDeveloped+=1

	return whiteMinorPiecesDeveloped - blackMinorPiecesDeveloped

#################################################################
# PRESSURE        				                          		#        
#################################################################

def get_pressure(white,black):
	return white.pressureCount - black.pressureCount


#################################################################
# MAIN EVALUATION                                   		#        
#################################################################

def dot_product(v1,v2):
	# used to apply constants to each valuation component
	return sum(el1*el2 for el1,el2 in zip(v1,v2))

CONSTANTS = [
	70, # Material
	0.5, # Piece Square Table Values
	1, # Center Control
	3, # Connectivity
	2.2, # Mobility
	0.2, # Bishop Pair bonus
	2, # Pawn structure score
	5, # Development
	1, #pressure
]

class Valuator:

	def __init__(self):
		self.cache = {}

	def __call__(self, position):
		board = position.board
		white = board.get_player(WHITE)
		black = board.get_player(BLACK)
		numWhitePieces = len(white.pieces)
		numBlackPieces = len(black.pieces)

		# material is most important component to evaluation
		material = count_material_difference(white,black)

		# pst, connectivity, and balance are correlated 
		# to the number of pieces a player has. Since material
		# already takes the number of pieces into account, 
		# the values for each color should be divided by 
		# their respective number of pieces
		pst = count_pst_values(white,black,numWhitePieces,numBlackPieces)
		connectivity = get_connectivity(white,black,numWhitePieces,numBlackPieces)
		mobility = get_mobility(position,numWhitePieces,numBlackPieces)

		# these values are not correlated to the number of pieces
		# and are more important in the opening than in the midgame
		centerControl = get_center_control(white,black)
		development = get_development(white,black)

		# bonuses
		bishopPairBonus = get_bishop_pair_bonus(white,black)
		pawnStructureScore = get_pawn_structure_score(white,black)

		pressure = get_pressure(white,black)

		scores = [	
			material,
			pst,
			centerControl,
			connectivity,
			mobility,
			bishopPairBonus,
			pawnStructureScore,
			development,
			pressure,
		]

		# apply constants to scores 
		valuation = dot_product(scores,CONSTANTS)
		return valuation

valuator = Valuator()


